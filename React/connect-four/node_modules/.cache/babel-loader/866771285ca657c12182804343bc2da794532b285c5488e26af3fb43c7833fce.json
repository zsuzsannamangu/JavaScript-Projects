{"ast":null,"code":"var _jsxFileName = \"/Users/zsuzsi/Documents/GitHub/JavaScript_Practice/React/connect-four/src/components/App/App.tsx\";\nimport React from \"react\";\nimport Board from \"../Board/Board\";\nimport styles from \"./App.module.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default class App extends React.PureComponent {\n  constructor(...args) {\n    super(...args);\n    //State is internal to the component, while Props are external data passed down from parent component. State is mutable, meaning it can change over time.\n    //State is essential for handling data that changes due to user interactions, network requests, or any other dynamic updates in an application. By using state, React makes it easy to manage and render UI changes in response to these updates automatically.\n    this.state = {\n      chipsPositions: {},\n      playerTurn: \"red\",\n      gameStatus: \"It's red's turn!\"\n    };\n    this.calculateGameStatus = (playerTurn, chipsPositions) => {\n      const {\n        columns,\n        rows\n      } = this.props;\n\n      //Check four in a row horizontally\n      for (let row = 0; row < rows; row++) {\n        let repetitionCountStatus = {\n          playerChip: \"\",\n          count: 0\n        };\n        for (let column = 0; column < columns; column++) {\n          const chip = chipsPositions[`${row}: ${column}`];\n\n          //If there is a chip in that position, and belongs to a player, count that chip for that player\n          //(either increase the count or start over)\n          if (chip && chip === repetitionCountStatus.playerChip) {\n            repetitionCountStatus.count++;\n          } else {\n            repetitionCountStatus = {\n              playerChip: chip,\n              count: 1\n            };\n          }\n\n          //If the count for a player is 4, that player won\n          if (repetitionCountStatus.count === 4) {\n            return `Player ${repetitionCountStatus.playerChip} won!`;\n          }\n        }\n      }\n\n      //Check four in a row vertically\n      for (let column = 0; column < columns; column++) {\n        let repetitionCountStatus = {\n          playerChip: \"\",\n          count: 0\n        };\n        for (let row = 0; row < rows; row++) {\n          const chip = chipsPositions[`${row}:${column}`];\n          //If there is a chip in that position, and belongs to a player, count that chip for that player\n          //either increase the count or start over\n          if (chip && chip === repetitionCountStatus.playerChip) {\n            repetitionCountStatus.count++;\n          } else {\n            repetitionCountStatus = {\n              playerChip: chip,\n              count: 1\n            };\n          }\n\n          //If the count for a player is 4, that player won\n          if (repetitionCountStatus.count === 4) {\n            return `Player ${repetitionCountStatus.playerChip} won!`;\n          }\n        }\n      }\n\n      //todo: check four in a row diagonally\n\n      return `It's ${playerTurn}'s turn`;\n    };\n    this.handleTileClick = tileId => {\n      const {\n        chipsPositions,\n        playerTurn\n      } = this.state;\n\n      //Get the last empty tile of the column\n      const column = parseInt(tileId.split(\":\")[1]);\n      let lastEmptyTileId = this.getLastEmptyTile(column);\n\n      //If there is no empty tile in the column, do nothing\n      if (!lastEmptyTileId) {\n        return;\n      }\n\n      //Add chip to empty tile\n      const newChipsPositions = {\n        ...chipsPositions,\n        [lastEmptyTileId]: playerTurn\n      };\n\n      //Change player turn\n      const newPlayerTurn = playerTurn == \"red\" ? \"yellow\" : \"red\";\n\n      //Calculate game status\n      const gameStatus = this.calculateGameStatus(newPlayerTurn, newChipsPositions);\n\n      //Save new state\n      this.setState({\n        chipsPositions: newChipsPositions,\n        playerTurn: newPlayerTurn,\n        gameStatus\n      });\n    };\n  }\n  getLastEmptyTile(column) {\n    const {\n      rows\n    } = this.props;\n    const {\n      chipsPositions\n    } = this.state;\n    for (let row = rows - 1; row >= 0; row--) {\n      const tileId = `${row}:${column}`;\n      if (!chipsPositions[tileId]) {\n        return tileId;\n      }\n    }\n  }\n  renderBoard() {\n    const {\n      columns,\n      rows\n    } = this.props;\n    const {\n      chipsPositions\n    } = this.state;\n    return /*#__PURE__*/_jsxDEV(Board, {\n      columns: columns,\n      rows: rows,\n      chipPositions: chipsPositions,\n      onTileClick: this.handleTileClick\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 112,\n      columnNumber: 13\n    }, this);\n  }\n  renderStatusMessage() {\n    const {\n      gameStatus\n    } = this.state;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.statusMessage,\n      children: [gameStatus, \" \"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 123,\n      columnNumber: 16\n    }, this);\n  }\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.app,\n      children: [this.renderBoard(), this.renderStatusMessage()]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 128,\n      columnNumber: 13\n    }, this);\n  }\n}","map":{"version":3,"names":["React","Board","styles","jsxDEV","_jsxDEV","App","PureComponent","constructor","args","state","chipsPositions","playerTurn","gameStatus","calculateGameStatus","columns","rows","props","row","repetitionCountStatus","playerChip","count","column","chip","handleTileClick","tileId","parseInt","split","lastEmptyTileId","getLastEmptyTile","newChipsPositions","newPlayerTurn","setState","renderBoard","chipPositions","onTileClick","fileName","_jsxFileName","lineNumber","columnNumber","renderStatusMessage","className","statusMessage","children","render","app"],"sources":["/Users/zsuzsi/Documents/GitHub/JavaScript_Practice/React/connect-four/src/components/App/App.tsx"],"sourcesContent":["import React from \"react\";\nimport Board from \"../Board/Board\";\nimport { Props, State, ChipsPositions } from \"./types\";\nimport styles from \"./App.module.css\";\n\nexport default class App extends React.PureComponent<Props, State> { //State is internal to the component, while Props are external data passed down from parent component. State is mutable, meaning it can change over time.\n    //State is essential for handling data that changes due to user interactions, network requests, or any other dynamic updates in an application. By using state, React makes it easy to manage and render UI changes in response to these updates automatically.\n\n    state: State = {\n        chipsPositions: {},\n        playerTurn: \"red\",\n        gameStatus: \"It's red's turn!\"\n    };\n\n    calculateGameStatus = (playerTurn: string, chipsPositions: ChipsPositions): string => {\n        const { columns, rows } = this.props;\n\n        //Check four in a row horizontally\n        for (let row = 0; row < rows; row++) {\n            let repetitionCountStatus = { playerChip: \"\", count: 0 };\n\n            for (let column = 0; column < columns; column++) {\n                const chip = chipsPositions[`${row}: ${column}`];\n\n                //If there is a chip in that position, and belongs to a player, count that chip for that player\n                //(either increase the count or start over)\n                if (chip && chip === repetitionCountStatus.playerChip) {\n                    repetitionCountStatus.count++;\n                } else {\n                    repetitionCountStatus = { playerChip: chip, count: 1 };\n                }\n\n                //If the count for a player is 4, that player won\n                if (repetitionCountStatus.count === 4) {\n                    return `Player ${repetitionCountStatus.playerChip} won!`;\n                }\n            }\n        }\n\n        //Check four in a row vertically\n        for (let column = 0; column < columns; column++) {\n            let repetitionCountStatus = { playerChip: \"\", count: 0 };\n\n            for (let row = 0;  row < rows; row++) {\n                const chip = chipsPositions[`${row}:${column}`];\n                //If there is a chip in that position, and belongs to a player, count that chip for that player\n                //either increase the count or start over\n                if (chip && chip === repetitionCountStatus.playerChip) {\n                    repetitionCountStatus.count++;\n                } else {\n                    repetitionCountStatus = { playerChip: chip, count: 1 };\n                }\n\n                //If the count for a player is 4, that player won\n                if (repetitionCountStatus.count === 4) {\n                    return `Player ${repetitionCountStatus.playerChip} won!`;\n                }\n            }\n        }\n\n        //todo: check four in a row diagonally\n\n        return `It's ${playerTurn}'s turn`;\n    };\n\n    handleTileClick = (tileId: string) => {\n        const { chipsPositions, playerTurn } = this.state;\n\n        //Get the last empty tile of the column\n        const column = parseInt(tileId.split(\":\")[1]);\n        let lastEmptyTileId = this.getLastEmptyTile(column);\n\n        //If there is no empty tile in the column, do nothing\n        if (!lastEmptyTileId) {\n            return;\n        }\n\n        //Add chip to empty tile\n        const newChipsPositions = {\n            ...chipsPositions,\n            [lastEmptyTileId]: playerTurn\n        };\n\n        //Change player turn\n        const newPlayerTurn = playerTurn == \"red\" ? \"yellow\" : \"red\";\n\n        //Calculate game status\n        const gameStatus = this.calculateGameStatus(newPlayerTurn, newChipsPositions);\n\n        //Save new state\n        this.setState({ chipsPositions: newChipsPositions, playerTurn: newPlayerTurn, gameStatus });\n    };\n\n    getLastEmptyTile(column: number) {\n        const { rows } = this.props;\n        const {chipsPositions} = this.state;\n        \n        for(let row = rows - 1; row >= 0; row--) {\n            const tileId = `${row}:${column}`;\n\n            if (!chipsPositions[tileId]) {\n                return tileId;\n            }\n        }\n    }\n   \n\n    renderBoard() {\n        const { columns, rows } = this.props;\n        const { chipsPositions } = this.state;\n        return (\n            <Board\n            columns={columns}\n            rows={rows}\n            chipPositions={chipsPositions}\n            onTileClick={this.handleTileClick}\n            />\n        );\n    }\n\n    renderStatusMessage() {\n        const { gameStatus } = this.state;\n        return <div className={styles.statusMessage}>{gameStatus} </div>;\n    }\n\n    render() {\n        return (\n            <div className={styles.app}>\n                {this.renderBoard()}\n                {this.renderStatusMessage()}\n            </div>\n        );\n    }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}