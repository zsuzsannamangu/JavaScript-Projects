{"ast":null,"code":"var _jsxFileName = \"/Users/zsuzsi/Documents/GitHub/JavaScript_Practice/React/connect-four/src/components/App/App.tsx\";\nimport React from \"react\";\nimport Board from \"../Board/Board\";\nimport styles from \"./App.module.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default class App extends React.PureComponent {\n  constructor(...args) {\n    super(...args);\n    //State is internal to the component, while Props are external data passed down from parent component. \n    //State is mutable, meaning it can change over time, while Props are immutable within the child, but can change externally.\n    //State is essential for handling data that changes due to user interactions, network requests, or any other dynamic updates in an application. By using state, React makes it easy to manage and render UI changes in response to these updates automatically.\n    this.state = {\n      //initializes the component's state with 3 properties\n      chipsPositions: {},\n      //object to store the positions of chips\n      playerTurn: \"red\",\n      //a string to track the current player's turn\n      gameStatus: \"It's red's turn!\",\n      //a string that displays the game's current status\n      gameOver: false\n    };\n    this.calculateGameStatus = (playerTurn, chipsPositions) => {\n      //This function returns a string, which is either: A message declaring the winning player or a message indicating it’s the next player’s turn if no win condition is met.\n\n      const {\n        columns,\n        rows\n      } = this.props; //Retrieves columns and rows from the component’s props to define the grid’s dimensions.\n\n      //Check four in a row horizontally\n      for (let row = 0; row < rows; row++) {\n        let repetitionCountStatus = {\n          playerChip: \"\",\n          count: 0\n        }; //repetitionCountStatus: A helper object used to track consecutive chips in each row.\n        //playerChip: Stores the current player’s chip type being counted (either \"red\" or \"yellow\"). count: Tracks the number of consecutive chips found for the playerChip.\n\n        for (let column = 0; column < columns; column++) {\n          const chip = chipsPositions[`${row}: ${column}`]; //Uses chipsPositions to check if there’s a chip at the current position (row:column)\n\n          //If there is a chip in that position, and belongs to a player, count that chip for that player\n          //(either increase the count or start over)\n          if (chip && chip === repetitionCountStatus.playerChip) {\n            //Condition: Checks if there’s a chip in the current position (chip is defined) and if it matches the playerChip currently being counted.\n            repetitionCountStatus.count++; //if true, Increments the count by 1 because it matches the last counted playerChip.\n          } else {\n            repetitionCountStatus = {\n              playerChip: chip,\n              count: 1\n            }; //if false, resets repetitionCountStatus to start a new count, sets playerChip to the current chip (or empty) and initializes count to 1\n          }\n\n          //If the count for a player is 4, that player won\n          if (repetitionCountStatus.count === 4) {\n            return `Player ${repetitionCountStatus.playerChip} won!`; //if true, returns a string announcing the win for playerChip\n          }\n        }\n      }\n\n      //Check four in a row vertically\n      for (let column = 0; column < columns; column++) {\n        let repetitionCountStatus = {\n          playerChip: \"\",\n          count: 0\n        };\n        for (let row = 0; row < rows; row++) {\n          const chip = chipsPositions[`${row}:${column}`];\n          //If there is a chip in that position, and belongs to a player, count that chip for that player\n          //either increase the count or start over\n          if (chip && chip === repetitionCountStatus.playerChip) {\n            repetitionCountStatus.count++;\n          } else {\n            repetitionCountStatus = {\n              playerChip: chip,\n              count: 1\n            };\n          }\n\n          //If the count for a player is 4, that player won\n          if (repetitionCountStatus.count === 4) {\n            return `Player ${repetitionCountStatus.playerChip} won!`;\n          }\n        }\n      }\n\n      // Check four in a row diagonally (top-left to bottom-right)\n      for (let row = 0; row < rows; row++) {\n        for (let column = 0; column < columns; column++) {\n          //iterates over each cell looking at rows and columns\n          const chip = chipsPositions[`${row}:${column}`];\n          if (chip) {\n            // Check top-left to bottom-right\n            if (row + 3 < rows && column + 3 < columns &&\n            //Ensures we don’t go out of bounds when moving diagonally downwards and to the right.\n            chip === chipsPositions[`${row + 1}:${column + 1}`] && chip === chipsPositions[`${row + 2}:${column + 2}`] && chip === chipsPositions[`${row + 3}:${column + 3}`]) {\n              return `Player ${chip} won!`;\n            }\n\n            // Check bottom-left to top-right\n            if (row - 3 >= 0 && column + 3 < columns && chip === chipsPositions[`${row - 1}:${column + 1}`] && chip === chipsPositions[`${row - 2}:${column + 2}`] && chip === chipsPositions[`${row - 3}:${column + 3}`]) {\n              return `Player ${chip} won!`;\n            }\n          }\n        }\n      }\n      return `It's ${playerTurn}'s turn`;\n    };\n    this.handleTileClick = tileId => {\n      //This function updates the game state by placing a chip in the tile that is clicked\n      if (this.state.gameOver) {\n        //check whether the game is over\n        return; //exit the function if the game is over\n      }\n      const {\n        chipsPositions,\n        playerTurn\n      } = this.state;\n\n      //Get the last empty tile of the column\n      const column = parseInt(tileId.split(\":\")[1]); //split the tileId string at the colon (:), so we can see the row and column (as tile id is x:y, x for row and y for column), and accessing the second element [1], to get the column part. \n      //And convert it to a number with parseInt(). So column const now contains the number value of the clicked column\n      let lastEmptyTileId = this.getLastEmptyTile(column); //refers to the getLastEmptyTile() function that is specified below that identifies the lowest empty/available tile in a specified column\n\n      //If there is no empty tile in the column, do nothing\n      if (!lastEmptyTileId) {\n        //Checks if lastEmptyTileId is falsy, meaning that there is no empty tile in the colum\n        return; //if true, exits the function\n      }\n\n      //Add chip to empty tile\n      const newChipsPositions = {\n        ...chipsPositions,\n        //The ...chipsPositions syntax is the spread operator in JavaScript. Means that all properties from the chipsPositions object are being copied into a new object, newChipsPositions. Modifications in newChipsPositions won't affect chipsPositions\n        [lastEmptyTileId]: playerTurn //adding a new property to newChipsPositions with the key [lastEmptyTileId] and the value playerTurn, effectively placing the current player's chip in the lowest available column\n      };\n\n      //Change player turn\n      const newPlayerTurn = playerTurn == \"red\" ? \"yellow\" : \"red\"; //determines who the next player is by checking the current playerTurn, if it's red, set to yellow, otherwise it's red\n\n      //Calculate game status\n      const gameStatus = this.calculateGameStatus(newPlayerTurn, newChipsPositions); //calls calculateGameStatus() function to determine whether there is a win\n\n      //Check whether someone won and if so update gameOver\n      const gameOver = gameStatus.includes(\"won\");\n\n      //Save new state\n      this.setState({\n        chipsPositions: newChipsPositions,\n        playerTurn: newPlayerTurn,\n        gameStatus,\n        gameOver\n      }); //the React built-in setState() method updates the component's state with new values. This method is inherited from React.PureComponent\n      //setState() tells React that the component’s state has changed and that it needs to update. React then schedules a re-render of the component with the updated state values. Then it merges the new state with the current state. this.state will contain the updated state values.\n    };\n  }\n  getLastEmptyTile(column) {\n    //identifies the lowest empty/available tile in a specified column\n    const {\n      rows\n    } = this.props;\n    const {\n      chipsPositions\n    } = this.state;\n    for (let row = rows - 1; row >= 0; row--) {\n      //this loops is going downward, starting at the total number of rows minus 1, until it reaches zero\n      const tileId = `${row}:${column}`; //\n\n      if (!chipsPositions[tileId]) {\n        //Each key in chipsPositions is a tile ID (formatted as \"row:column\"), and the value represents the player’s chip at that position (for example, \"red\" or \"yellow\").\n        //chipsPositions[tileId] checks if there is a chip in the specified tile. tileId is the current tile's ID. ! negates this check.\n        //So !chipPositions[tileId] will be true if the tile is empty and in that case it returns the tileId\n        return tileId;\n        //This effectively ends the function early, providing the ID of the first empty tile it encounters.\n      }\n    }\n  }\n  renderBoard() {\n    const {\n      columns,\n      rows\n    } = this.props;\n    const {\n      chipsPositions\n    } = this.state;\n    return /*#__PURE__*/_jsxDEV(Board, {\n      columns: columns,\n      rows: rows,\n      chipPositions: chipsPositions,\n      onTileClick: this.handleTileClick\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 154,\n      columnNumber: 13\n    }, this);\n  }\n  renderStatusMessage() {\n    const {\n      gameStatus,\n      gameOver\n    } = this.state;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.statusMessage,\n      children: [gameStatus, \" \", gameOver && /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Game over\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 165,\n        columnNumber: 80\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 165,\n      columnNumber: 16\n    }, this);\n    //The statusMessage styles are applied to the div element, ensuring the styles are isolated and applied only within this component.\n  }\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.app,\n      children: [this.renderBoard(), this.renderStatusMessage()]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 171,\n      columnNumber: 13\n    }, this);\n  }\n}","map":{"version":3,"names":["React","Board","styles","jsxDEV","_jsxDEV","App","PureComponent","constructor","args","state","chipsPositions","playerTurn","gameStatus","gameOver","calculateGameStatus","columns","rows","props","row","repetitionCountStatus","playerChip","count","column","chip","handleTileClick","tileId","parseInt","split","lastEmptyTileId","getLastEmptyTile","newChipsPositions","newPlayerTurn","includes","setState","renderBoard","chipPositions","onTileClick","fileName","_jsxFileName","lineNumber","columnNumber","renderStatusMessage","className","statusMessage","children","render","app"],"sources":["/Users/zsuzsi/Documents/GitHub/JavaScript_Practice/React/connect-four/src/components/App/App.tsx"],"sourcesContent":["import React from \"react\";\nimport Board from \"../Board/Board\";\nimport { Props, State, ChipsPositions } from \"./types\";\nimport styles from \"./App.module.css\";\n\nexport default class App extends React.PureComponent<Props, State> { //State is internal to the component, while Props are external data passed down from parent component. \n    //State is mutable, meaning it can change over time, while Props are immutable within the child, but can change externally.\n    //State is essential for handling data that changes due to user interactions, network requests, or any other dynamic updates in an application. By using state, React makes it easy to manage and render UI changes in response to these updates automatically.\n\n    state: State = { //initializes the component's state with 3 properties\n        chipsPositions: {}, //object to store the positions of chips\n        playerTurn: \"red\", //a string to track the current player's turn\n        gameStatus: \"It's red's turn!\", //a string that displays the game's current status\n        gameOver: false\n    };\n\n    calculateGameStatus = (playerTurn: string, chipsPositions: ChipsPositions): string => { //This function returns a string, which is either: A message declaring the winning player or a message indicating it’s the next player’s turn if no win condition is met.\n        \n        const { columns, rows } = this.props; //Retrieves columns and rows from the component’s props to define the grid’s dimensions.\n\n        //Check four in a row horizontally\n        for (let row = 0; row < rows; row++) {\n            let repetitionCountStatus = { playerChip: \"\", count: 0 }; //repetitionCountStatus: A helper object used to track consecutive chips in each row.\n            //playerChip: Stores the current player’s chip type being counted (either \"red\" or \"yellow\"). count: Tracks the number of consecutive chips found for the playerChip.\n\n            for (let column = 0; column < columns; column++) {\n                const chip = chipsPositions[`${row}: ${column}`]; //Uses chipsPositions to check if there’s a chip at the current position (row:column)\n\n                //If there is a chip in that position, and belongs to a player, count that chip for that player\n                //(either increase the count or start over)\n                if (chip && chip === repetitionCountStatus.playerChip) { //Condition: Checks if there’s a chip in the current position (chip is defined) and if it matches the playerChip currently being counted.\n                    repetitionCountStatus.count++; //if true, Increments the count by 1 because it matches the last counted playerChip.\n                } else {\n                    repetitionCountStatus = { playerChip: chip, count: 1 }; //if false, resets repetitionCountStatus to start a new count, sets playerChip to the current chip (or empty) and initializes count to 1\n                }\n\n                //If the count for a player is 4, that player won\n                if (repetitionCountStatus.count === 4) {\n                    return `Player ${repetitionCountStatus.playerChip} won!`; //if true, returns a string announcing the win for playerChip\n                }\n            }\n        }\n\n        //Check four in a row vertically\n        for (let column = 0; column < columns; column++) {\n            let repetitionCountStatus = { playerChip: \"\", count: 0 };\n\n            for (let row = 0;  row < rows; row++) {\n                const chip = chipsPositions[`${row}:${column}`];\n                //If there is a chip in that position, and belongs to a player, count that chip for that player\n                //either increase the count or start over\n                if (chip && chip === repetitionCountStatus.playerChip) {\n                    repetitionCountStatus.count++;\n                } else {\n                    repetitionCountStatus = { playerChip: chip, count: 1 };\n                }\n\n                //If the count for a player is 4, that player won\n                if (repetitionCountStatus.count === 4) {\n                    return `Player ${repetitionCountStatus.playerChip} won!`;\n                }\n            }\n        }\n\n        // Check four in a row diagonally (top-left to bottom-right)\n        for (let row = 0; row < rows; row++) {\n            for (let column = 0; column < columns; column++) { //iterates over each cell looking at rows and columns\n                const chip = chipsPositions[`${row}:${column}`];\n                if (chip) {\n                    // Check top-left to bottom-right\n                    if (\n                        row + 3 < rows &&\n                        column + 3 < columns && //Ensures we don’t go out of bounds when moving diagonally downwards and to the right.\n                        chip === chipsPositions[`${row + 1}:${column + 1}`] &&\n                        chip === chipsPositions[`${row + 2}:${column + 2}`] &&\n                        chip === chipsPositions[`${row + 3}:${column + 3}`]\n                    ) {\n                        return `Player ${chip} won!`;\n                    }\n\n                    // Check bottom-left to top-right\n                    if (\n                        row - 3 >= 0 &&\n                        column + 3 < columns &&\n                        chip === chipsPositions[`${row - 1}:${column + 1}`] &&\n                        chip === chipsPositions[`${row - 2}:${column + 2}`] &&\n                        chip === chipsPositions[`${row - 3}:${column + 3}`]\n                    ) {\n                        return `Player ${chip} won!`;\n                    }\n                }\n            }\n        }\n\n        return `It's ${playerTurn}'s turn`;\n    };\n\n    handleTileClick = (tileId: string) => { //This function updates the game state by placing a chip in the tile that is clicked\n        if (this.state.gameOver) { //check whether the game is over\n            return; //exit the function if the game is over\n        }\n        const { chipsPositions, playerTurn } = this.state;\n\n        //Get the last empty tile of the column\n        const column = parseInt(tileId.split(\":\")[1]); //split the tileId string at the colon (:), so we can see the row and column (as tile id is x:y, x for row and y for column), and accessing the second element [1], to get the column part. \n        //And convert it to a number with parseInt(). So column const now contains the number value of the clicked column\n        let lastEmptyTileId = this.getLastEmptyTile(column); //refers to the getLastEmptyTile() function that is specified below that identifies the lowest empty/available tile in a specified column\n\n        //If there is no empty tile in the column, do nothing\n        if (!lastEmptyTileId) { //Checks if lastEmptyTileId is falsy, meaning that there is no empty tile in the colum\n            return; //if true, exits the function\n        }\n\n        //Add chip to empty tile\n        const newChipsPositions = {\n            ...chipsPositions, //The ...chipsPositions syntax is the spread operator in JavaScript. Means that all properties from the chipsPositions object are being copied into a new object, newChipsPositions. Modifications in newChipsPositions won't affect chipsPositions\n            [lastEmptyTileId]: playerTurn //adding a new property to newChipsPositions with the key [lastEmptyTileId] and the value playerTurn, effectively placing the current player's chip in the lowest available column\n        };\n\n        //Change player turn\n        const newPlayerTurn = playerTurn == \"red\" ? \"yellow\" : \"red\"; //determines who the next player is by checking the current playerTurn, if it's red, set to yellow, otherwise it's red\n\n        //Calculate game status\n        const gameStatus = this.calculateGameStatus(newPlayerTurn, newChipsPositions); //calls calculateGameStatus() function to determine whether there is a win\n\n        //Check whether someone won and if so update gameOver\n        const gameOver = gameStatus.includes(\"won\");\n\n        //Save new state\n        this.setState({ chipsPositions: newChipsPositions, playerTurn: newPlayerTurn, gameStatus, gameOver }); //the React built-in setState() method updates the component's state with new values. This method is inherited from React.PureComponent\n        //setState() tells React that the component’s state has changed and that it needs to update. React then schedules a re-render of the component with the updated state values. Then it merges the new state with the current state. this.state will contain the updated state values.\n    };\n\n    getLastEmptyTile(column: number) { //identifies the lowest empty/available tile in a specified column\n        const { rows } = this.props;\n        const { chipsPositions } = this.state;\n        \n        for(let row = rows - 1; row >= 0; row--) { //this loops is going downward, starting at the total number of rows minus 1, until it reaches zero\n            const tileId = `${row}:${column}`; //\n\n            if (!chipsPositions[tileId]) { //Each key in chipsPositions is a tile ID (formatted as \"row:column\"), and the value represents the player’s chip at that position (for example, \"red\" or \"yellow\").\n                //chipsPositions[tileId] checks if there is a chip in the specified tile. tileId is the current tile's ID. ! negates this check.\n                //So !chipPositions[tileId] will be true if the tile is empty and in that case it returns the tileId\n                return tileId;\n                //This effectively ends the function early, providing the ID of the first empty tile it encounters.\n            }\n        }\n    }\n   \n    renderBoard() {\n        const { columns, rows } = this.props;\n        const { chipsPositions } = this.state;\n        return (\n            <Board\n            columns={columns}\n            rows={rows}\n            chipPositions={chipsPositions}\n            onTileClick={this.handleTileClick}\n            />\n        );\n    }\n\n    renderStatusMessage() {\n        const { gameStatus, gameOver } = this.state;\n        return <div className={styles.statusMessage}>{gameStatus} {gameOver && <p>Game over</p>}</div>;\n        //The statusMessage styles are applied to the div element, ensuring the styles are isolated and applied only within this component.\n    }\n\n    render() {\n        return (\n            <div className={styles.app}>\n                {this.renderBoard()}\n                {this.renderStatusMessage()}\n            </div>\n        );\n    }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}