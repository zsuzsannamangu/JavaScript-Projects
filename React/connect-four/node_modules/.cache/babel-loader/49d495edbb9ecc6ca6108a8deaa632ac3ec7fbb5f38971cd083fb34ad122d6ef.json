{"ast":null,"code":"var _jsxFileName = \"/Users/zsuzsi/Documents/GitHub/JavaScript_Practice/React/connect-four/src/components/App/App.tsx\";\nimport React from \"react\";\nimport Board from \"../Board/Board\";\nimport styles from \"./App.module.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default class App extends React.PureComponent {\n  constructor(...args) {\n    super(...args);\n    //State is internal to the component, while Props are external data passed down from parent component. \n    //State is mutable, meaning it can change over time, while Props are immutable within the child, but can change externally.\n    //State is essential for handling data that changes due to user interactions, network requests, or any other dynamic updates in an application. By using state, React makes it easy to manage and render UI changes in response to these updates automatically.\n    this.state = {\n      //initializes the component's state with 3 properties\n      chipsPositions: {},\n      //object to store the positions of chips\n      playerTurn: \"red\",\n      //a string to track the current player's turn\n      gameStatus: \"It's red's turn!\" //a string that displays the game's current status\n    };\n    this.calculateGameStatus = (playerTurn, chipsPositions) => {\n      //This function returns a string, which is either: A message declaring the winning player or a message indicating it’s the next player’s turn if no win condition is met.\n\n      const {\n        columns,\n        rows\n      } = this.props; //Retrieves columns and rows from the component’s props to define the grid’s dimensions.\n\n      //Check four in a row horizontally\n      for (let row = 0; row < rows; row++) {\n        let repetitionCountStatus = {\n          playerChip: \"\",\n          count: 0\n        }; //repetitionCountStatus: A helper object used to track consecutive chips in each row.\n        //playerChip: Stores the current player’s chip type being counted (either \"red\" or \"yellow\"). count: Tracks the number of consecutive chips found for the playerChip.\n\n        for (let column = 0; column < columns; column++) {\n          const chip = chipsPositions[`${row}: ${column}`]; //Uses chipsPositions to check if there’s a chip at the current position (row:column)\n\n          //If there is a chip in that position, and belongs to a player, count that chip for that player\n          //(either increase the count or start over)\n          if (chip && chip === repetitionCountStatus.playerChip) {\n            //Condition: Checks if there’s a chip in the current position (chip is defined) and if it matches the playerChip currently being counted.\n            repetitionCountStatus.count++; //if true, Increments the count by 1 because it matches the last counted playerChip.\n          } else {\n            repetitionCountStatus = {\n              playerChip: chip,\n              count: 1\n            }; //if false, resets repetitionCountStatus to start a new count, sets playerChip to the current chip (or empty) and initializes count to 1\n          }\n\n          //If the count for a player is 4, that player won\n          if (repetitionCountStatus.count === 4) {\n            return `Player ${repetitionCountStatus.playerChip} won!`; //if true, returns a string announcing the win for playerChip\n          }\n        }\n      }\n\n      //Check four in a row vertically\n      for (let column = 0; column < columns; column++) {\n        let repetitionCountStatus = {\n          playerChip: \"\",\n          count: 0\n        };\n        for (let row = 0; row < rows; row++) {\n          const chip = chipsPositions[`${row}:${column}`];\n          //If there is a chip in that position, and belongs to a player, count that chip for that player\n          //either increase the count or start over\n          if (chip && chip === repetitionCountStatus.playerChip) {\n            repetitionCountStatus.count++;\n          } else {\n            repetitionCountStatus = {\n              playerChip: chip,\n              count: 1\n            };\n          }\n\n          //If the count for a player is 4, that player won\n          if (repetitionCountStatus.count === 4) {\n            return `Player ${repetitionCountStatus.playerChip} won!`;\n          }\n        }\n      }\n\n      //todo: check four in a row diagonally\n\n      return `It's ${playerTurn}'s turn`;\n    };\n    this.handleTileClick = tileId => {\n      //This function updates the game state by placing a chip in the tile that is clicked\n      const {\n        chipsPositions,\n        playerTurn\n      } = this.state;\n\n      //Get the last empty tile of the column\n      const column = parseInt(tileId.split(\":\")[1]); //split the tileId string at the colon (:), so we can see the row and column (as tile id is x:y, x for row and y for column), and accessing the second element [1], to get the column part. \n      //And convert it to a number with parseInt()\n      let lastEmptyTileId = this.getLastEmptyTile(column); //\n\n      //If there is no empty tile in the column, do nothing\n      if (!lastEmptyTileId) {\n        return;\n      }\n\n      //Add chip to empty tile\n      const newChipsPositions = {\n        ...chipsPositions,\n        [lastEmptyTileId]: playerTurn\n      };\n\n      //Change player turn\n      const newPlayerTurn = playerTurn == \"red\" ? \"yellow\" : \"red\";\n\n      //Calculate game status\n      const gameStatus = this.calculateGameStatus(newPlayerTurn, newChipsPositions);\n\n      //Save new state\n      this.setState({\n        chipsPositions: newChipsPositions,\n        playerTurn: newPlayerTurn,\n        gameStatus\n      });\n    };\n  }\n  getLastEmptyTile(column) {\n    const {\n      rows\n    } = this.props;\n    const {\n      chipsPositions\n    } = this.state;\n    for (let row = rows - 1; row >= 0; row--) {\n      const tileId = `${row}:${column}`;\n      if (!chipsPositions[tileId]) {\n        return tileId;\n      }\n    }\n  }\n  renderBoard() {\n    const {\n      columns,\n      rows\n    } = this.props;\n    const {\n      chipsPositions\n    } = this.state;\n    return /*#__PURE__*/_jsxDEV(Board, {\n      columns: columns,\n      rows: rows,\n      chipPositions: chipsPositions,\n      onTileClick: this.handleTileClick\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 116,\n      columnNumber: 13\n    }, this);\n  }\n  renderStatusMessage() {\n    const {\n      gameStatus\n    } = this.state;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.statusMessage,\n      children: [gameStatus, \" \"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 127,\n      columnNumber: 16\n    }, this);\n  }\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.app,\n      children: [this.renderBoard(), this.renderStatusMessage()]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 132,\n      columnNumber: 13\n    }, this);\n  }\n}","map":{"version":3,"names":["React","Board","styles","jsxDEV","_jsxDEV","App","PureComponent","constructor","args","state","chipsPositions","playerTurn","gameStatus","calculateGameStatus","columns","rows","props","row","repetitionCountStatus","playerChip","count","column","chip","handleTileClick","tileId","parseInt","split","lastEmptyTileId","getLastEmptyTile","newChipsPositions","newPlayerTurn","setState","renderBoard","chipPositions","onTileClick","fileName","_jsxFileName","lineNumber","columnNumber","renderStatusMessage","className","statusMessage","children","render","app"],"sources":["/Users/zsuzsi/Documents/GitHub/JavaScript_Practice/React/connect-four/src/components/App/App.tsx"],"sourcesContent":["import React from \"react\";\nimport Board from \"../Board/Board\";\nimport { Props, State, ChipsPositions } from \"./types\";\nimport styles from \"./App.module.css\";\n\nexport default class App extends React.PureComponent<Props, State> { //State is internal to the component, while Props are external data passed down from parent component. \n    //State is mutable, meaning it can change over time, while Props are immutable within the child, but can change externally.\n    //State is essential for handling data that changes due to user interactions, network requests, or any other dynamic updates in an application. By using state, React makes it easy to manage and render UI changes in response to these updates automatically.\n\n    state: State = { //initializes the component's state with 3 properties\n        chipsPositions: {}, //object to store the positions of chips\n        playerTurn: \"red\", //a string to track the current player's turn\n        gameStatus: \"It's red's turn!\" //a string that displays the game's current status\n    };\n\n    calculateGameStatus = (playerTurn: string, chipsPositions: ChipsPositions): string => { //This function returns a string, which is either: A message declaring the winning player or a message indicating it’s the next player’s turn if no win condition is met.\n        \n        const { columns, rows } = this.props; //Retrieves columns and rows from the component’s props to define the grid’s dimensions.\n\n        //Check four in a row horizontally\n        for (let row = 0; row < rows; row++) {\n            let repetitionCountStatus = { playerChip: \"\", count: 0 }; //repetitionCountStatus: A helper object used to track consecutive chips in each row.\n            //playerChip: Stores the current player’s chip type being counted (either \"red\" or \"yellow\"). count: Tracks the number of consecutive chips found for the playerChip.\n\n            for (let column = 0; column < columns; column++) {\n                const chip = chipsPositions[`${row}: ${column}`]; //Uses chipsPositions to check if there’s a chip at the current position (row:column)\n\n                //If there is a chip in that position, and belongs to a player, count that chip for that player\n                //(either increase the count or start over)\n                if (chip && chip === repetitionCountStatus.playerChip) { //Condition: Checks if there’s a chip in the current position (chip is defined) and if it matches the playerChip currently being counted.\n                    repetitionCountStatus.count++; //if true, Increments the count by 1 because it matches the last counted playerChip.\n                } else {\n                    repetitionCountStatus = { playerChip: chip, count: 1 }; //if false, resets repetitionCountStatus to start a new count, sets playerChip to the current chip (or empty) and initializes count to 1\n                }\n\n                //If the count for a player is 4, that player won\n                if (repetitionCountStatus.count === 4) {\n                    return `Player ${repetitionCountStatus.playerChip} won!`; //if true, returns a string announcing the win for playerChip\n                }\n            }\n        }\n\n        //Check four in a row vertically\n        for (let column = 0; column < columns; column++) {\n            let repetitionCountStatus = { playerChip: \"\", count: 0 };\n\n            for (let row = 0;  row < rows; row++) {\n                const chip = chipsPositions[`${row}:${column}`];\n                //If there is a chip in that position, and belongs to a player, count that chip for that player\n                //either increase the count or start over\n                if (chip && chip === repetitionCountStatus.playerChip) {\n                    repetitionCountStatus.count++;\n                } else {\n                    repetitionCountStatus = { playerChip: chip, count: 1 };\n                }\n\n                //If the count for a player is 4, that player won\n                if (repetitionCountStatus.count === 4) {\n                    return `Player ${repetitionCountStatus.playerChip} won!`;\n                }\n            }\n        }\n\n        //todo: check four in a row diagonally\n\n        return `It's ${playerTurn}'s turn`;\n    };\n\n    handleTileClick = (tileId: string) => { //This function updates the game state by placing a chip in the tile that is clicked\n        const { chipsPositions, playerTurn } = this.state;\n\n        //Get the last empty tile of the column\n        const column = parseInt(tileId.split(\":\")[1]); //split the tileId string at the colon (:), so we can see the row and column (as tile id is x:y, x for row and y for column), and accessing the second element [1], to get the column part. \n        //And convert it to a number with parseInt()\n        let lastEmptyTileId = this.getLastEmptyTile(column); //\n\n        //If there is no empty tile in the column, do nothing\n        if (!lastEmptyTileId) {\n            return;\n        }\n\n        //Add chip to empty tile\n        const newChipsPositions = {\n            ...chipsPositions,\n            [lastEmptyTileId]: playerTurn\n        };\n\n        //Change player turn\n        const newPlayerTurn = playerTurn == \"red\" ? \"yellow\" : \"red\";\n\n        //Calculate game status\n        const gameStatus = this.calculateGameStatus(newPlayerTurn, newChipsPositions);\n\n        //Save new state\n        this.setState({ chipsPositions: newChipsPositions, playerTurn: newPlayerTurn, gameStatus });\n    };\n\n    getLastEmptyTile(column: number) {\n        const { rows } = this.props;\n        const {chipsPositions} = this.state;\n        \n        for(let row = rows - 1; row >= 0; row--) {\n            const tileId = `${row}:${column}`;\n\n            if (!chipsPositions[tileId]) {\n                return tileId;\n            }\n        }\n    }\n   \n\n    renderBoard() {\n        const { columns, rows } = this.props;\n        const { chipsPositions } = this.state;\n        return (\n            <Board\n            columns={columns}\n            rows={rows}\n            chipPositions={chipsPositions}\n            onTileClick={this.handleTileClick}\n            />\n        );\n    }\n\n    renderStatusMessage() {\n        const { gameStatus } = this.state;\n        return <div className={styles.statusMessage}>{gameStatus} </div>;\n    }\n\n    render() {\n        return (\n            <div className={styles.app}>\n                {this.renderBoard()}\n                {this.renderStatusMessage()}\n            </div>\n        );\n    }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}