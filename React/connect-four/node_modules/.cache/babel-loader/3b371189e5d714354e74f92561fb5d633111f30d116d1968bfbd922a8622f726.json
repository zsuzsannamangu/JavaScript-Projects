{"ast":null,"code":"var _jsxFileName = \"/Users/zsuzsi/Documents/GitHub/JavaScript_Practice/React/connect-four/src/components/App/App.tsx\";\nimport React from \"react\";\nimport Board from \"../Board/Board\";\nimport styles from \"./App.module.css\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport default class App extends React.PureComponent {\n  constructor(...args) {\n    super(...args);\n    //State is internal to the component, while Props are external data passed down from parent component. \n    //State is mutable, meaning it can change over time, while Props are immutable within the child, but can change externally.\n    //State is essential for handling data that changes due to user interactions, network requests, or any other dynamic updates in an application. By using state, React makes it easy to manage and render UI changes in response to these updates automatically.\n    this.state = {\n      //initializes the component's state with 3 properties\n      chipsPositions: {},\n      //object to store the positions of chips\n      playerTurn: \"red\",\n      //a string to track the current player's turn\n      gameStatus: \"It's red's turn!\",\n      //a string that displays the game's current status\n      gameOver: false\n    };\n    this.calculateGameStatus = (playerTurn, chipsPositions) => {\n      //This function returns a string, which is either: A message declaring the winning player or a message indicating it’s the next player’s turn if no win condition is met.\n\n      const {\n        columns,\n        rows\n      } = this.props; //Retrieves columns and rows from the component’s props to define the grid’s dimensions.\n\n      //Horizontal check:\n      for (let row = 0; row < rows; row++) {\n        let count = 0;\n        let lastChip = \"\";\n        for (let column = 0; column < columns; column++) {\n          const chip = chipsPositions[`${row}:${column}`];\n          if (chip && chip === lastChip) {\n            count++;\n          } else {\n            count = 1; // Reset count for new chip or empty space\n            lastChip = chip;\n          }\n\n          // If count reaches 4, we have a win\n          if (count === 4) {\n            return `Player ${lastChip} won!`;\n          }\n        }\n      }\n\n      //Vertical check:\n      for (let column = 0; column < columns; column++) {\n        let count = 0;\n        let lastChip = \"\";\n        for (let row = 0; row < rows; row++) {\n          const chip = chipsPositions[`${row}:${column}`];\n          if (chip && chip === lastChip) {\n            count++;\n          } else {\n            count = 1; // Reset count for new chip or empty space\n            lastChip = chip;\n          }\n\n          // If count reaches 4, we have a win\n          if (count === 4) {\n            return `Player ${lastChip} won!`;\n          }\n        }\n      }\n\n      //Check four in a row vertically\n      /*for (let column = 0; column < columns; column++) {\n          let repetitionCountStatus = { playerChip: \"\", count: 0 };\n           for (let row = 0;  row < rows; row++) {\n              const chip = chipsPositions[`${row}:${column}`];\n              //If there is a chip in that position, and belongs to a player, count that chip for that player\n              //either increase the count or start over\n              if (chip && chip === repetitionCountStatus.playerChip) {\n                  repetitionCountStatus.count++;\n              } else {\n                  repetitionCountStatus = { playerChip: chip, count: 1 };\n              }\n               //If the count for a player is 4, that player won\n              if (repetitionCountStatus.count === 4) {\n                  return `Player ${repetitionCountStatus.playerChip} won!`;\n              }\n          }\n      }*/\n\n      // Check four in a row diagonally (top-left to bottom-right)\n      for (let row = 0; row < rows; row++) {\n        for (let column = 0; column < columns; column++) {\n          //iterates over each cell looking at rows and columns\n          const chip = chipsPositions[`${row}:${column}`];\n          if (chip) {\n            // Check top-left to bottom-right\n            if (row + 3 < rows && column + 3 < columns &&\n            //Ensures we don’t go out of bounds when moving diagonally downwards and to the right.\n            chip === chipsPositions[`${row + 1}:${column + 1}`] && chip === chipsPositions[`${row + 2}:${column + 2}`] && chip === chipsPositions[`${row + 3}:${column + 3}`]) {\n              return `Player ${chip} won!`;\n            }\n\n            // Check bottom-left to top-right\n            if (row - 3 >= 0 && column + 3 < columns && chip === chipsPositions[`${row - 1}:${column + 1}`] && chip === chipsPositions[`${row - 2}:${column + 2}`] && chip === chipsPositions[`${row - 3}:${column + 3}`]) {\n              return `Player ${chip} won!`;\n            }\n          }\n        }\n      }\n\n      //check if the board is full, which is another way for the game to end\n      const isBoardFull = Object.keys(chipsPositions).length === rows * columns; //The length of this array (Object.keys(chipsPositions).length) tells us exactly how many tiles are filled. If this length matches the total number of cells (rows * columns), the board is full.\n      //Object.keys = returns an array of an object's own property names (keys), in this case the object is chipPositions. The keys of chipsPositions are \"0:0\", \"0:1\", \"1:0\", \"2:2\", etc, each property name is formatted as a row and column identifier.  Object.keys provides the count of occupied positions.\n      //chipPositions keeps track of the positions of chips on the game board.\n      if (isBoardFull) {\n        return \"It's a draw!\";\n      }\n\n      //If there is no win and the board is not full, it's the next player's turn\n      return `It's ${playerTurn}'s turn`;\n    };\n    this.handleTileClick = tileId => {\n      //This function updates the game state by placing a chip in the tile that is clicked\n      if (this.state.gameOver) {\n        //check whether the game is over\n        return; //exit the function if the game is over\n      }\n      const {\n        chipsPositions,\n        playerTurn\n      } = this.state;\n\n      //Get the last empty tile of the column\n      const column = parseInt(tileId.split(\":\")[1]); //split the tileId string at the colon (:), so we can see the row and column (as tile id is x:y, x for row and y for column), and accessing the second element [1], to get the column part. \n      //And convert it to a number with parseInt(). So column const now contains the number value of the clicked column\n      let lastEmptyTileId = this.getLastEmptyTile(column); //refers to the getLastEmptyTile() function that is specified below that identifies the lowest empty/available tile in a specified column\n\n      //If there is no empty tile in the column, do nothing\n      if (!lastEmptyTileId) {\n        //Checks if lastEmptyTileId is falsy, meaning that there is no empty tile in the colum\n        return; //if true, exits the function\n      }\n\n      //Add chip to empty tile\n      const newChipsPositions = {\n        ...chipsPositions,\n        //The ...chipsPositions syntax is the spread operator in JavaScript. Means that all properties from the chipsPositions object are being copied into a new object, newChipsPositions. Modifications in newChipsPositions won't affect chipsPositions\n        [lastEmptyTileId]: playerTurn //adding a new property to newChipsPositions with the key [lastEmptyTileId] and the value playerTurn, effectively placing the current player's chip in the lowest available column\n      };\n\n      //Change player turn\n      const newPlayerTurn = playerTurn == \"red\" ? \"yellow\" : \"red\"; //determines who the next player is by checking the current playerTurn, if it's red, set to yellow, otherwise it's red\n\n      //Calculate game status\n      const gameStatus = this.calculateGameStatus(newPlayerTurn, newChipsPositions); //calls calculateGameStatus() function to determine whether there is a win\n\n      //Determine if the game is over by checking whether the gameStatus string contains the word \"won\".\n      const gameOver = gameStatus.includes(\"won\");\n\n      //Save new state\n      this.setState({\n        chipsPositions: newChipsPositions,\n        playerTurn: newPlayerTurn,\n        gameStatus,\n        gameOver\n      }); //the React built-in setState() method updates the component's state with new values. This method is inherited from React.PureComponent\n      //setState() tells React that the component’s state has changed and that it needs to update. React then schedules a re-render of the component with the updated state values. Then it merges the new state with the current state. this.state will contain the updated state values.\n    };\n  }\n  getLastEmptyTile(column) {\n    //identifies the lowest empty/available tile in a specified column\n    const {\n      rows\n    } = this.props;\n    const {\n      chipsPositions\n    } = this.state;\n    for (let row = rows - 1; row >= 0; row--) {\n      //this loops is going downward, starting at the total number of rows minus 1, until it reaches zero\n      const tileId = `${row}:${column}`; //\n\n      if (!chipsPositions[tileId]) {\n        //Each key in chipsPositions is a tile ID (formatted as \"row:column\"), and the value represents the player’s chip at that position (for example, \"red\" or \"yellow\").\n        //chipsPositions[tileId] checks if there is a chip in the specified tile. tileId is the current tile's ID. ! negates this check.\n        //So !chipPositions[tileId] will be true if the tile is empty and in that case it returns the tileId\n        return tileId;\n        //This effectively ends the function early, providing the ID of the first empty tile it encounters.\n      }\n    }\n  }\n  renderBoard() {\n    const {\n      columns,\n      rows\n    } = this.props;\n    const {\n      chipsPositions\n    } = this.state;\n    return /*#__PURE__*/_jsxDEV(Board, {\n      columns: columns,\n      rows: rows,\n      chipPositions: chipsPositions,\n      onTileClick: this.handleTileClick\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 184,\n      columnNumber: 13\n    }, this);\n  }\n  renderStatusMessage() {\n    const {\n      gameStatus,\n      gameOver\n    } = this.state;\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.statusMessage,\n      children: [gameStatus, \" \", gameOver && /*#__PURE__*/_jsxDEV(\"p\", {\n        children: \"Game over\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 195,\n        columnNumber: 80\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 195,\n      columnNumber: 16\n    }, this);\n    //The statusMessage styles are applied to the div element, ensuring the styles are isolated and applied only within this component.\n  }\n  render() {\n    return /*#__PURE__*/_jsxDEV(\"div\", {\n      className: styles.app,\n      children: [this.renderBoard(), this.renderStatusMessage()]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 201,\n      columnNumber: 13\n    }, this);\n  }\n}","map":{"version":3,"names":["React","Board","styles","jsxDEV","_jsxDEV","App","PureComponent","constructor","args","state","chipsPositions","playerTurn","gameStatus","gameOver","calculateGameStatus","columns","rows","props","row","count","lastChip","column","chip","isBoardFull","Object","keys","length","handleTileClick","tileId","parseInt","split","lastEmptyTileId","getLastEmptyTile","newChipsPositions","newPlayerTurn","includes","setState","renderBoard","chipPositions","onTileClick","fileName","_jsxFileName","lineNumber","columnNumber","renderStatusMessage","className","statusMessage","children","render","app"],"sources":["/Users/zsuzsi/Documents/GitHub/JavaScript_Practice/React/connect-four/src/components/App/App.tsx"],"sourcesContent":["import React from \"react\";\nimport Board from \"../Board/Board\";\nimport { Props, State, ChipsPositions } from \"./types\";\nimport styles from \"./App.module.css\";\n\nexport default class App extends React.PureComponent<Props, State> { //State is internal to the component, while Props are external data passed down from parent component. \n    //State is mutable, meaning it can change over time, while Props are immutable within the child, but can change externally.\n    //State is essential for handling data that changes due to user interactions, network requests, or any other dynamic updates in an application. By using state, React makes it easy to manage and render UI changes in response to these updates automatically.\n\n    state: State = { //initializes the component's state with 3 properties\n        chipsPositions: {}, //object to store the positions of chips\n        playerTurn: \"red\", //a string to track the current player's turn\n        gameStatus: \"It's red's turn!\", //a string that displays the game's current status\n        gameOver: false\n    };\n\n    calculateGameStatus = (playerTurn: string, chipsPositions: ChipsPositions): string => { //This function returns a string, which is either: A message declaring the winning player or a message indicating it’s the next player’s turn if no win condition is met.\n        \n        const { columns, rows } = this.props; //Retrieves columns and rows from the component’s props to define the grid’s dimensions.\n\n        //Horizontal check:\n        for (let row = 0; row < rows; row++) {\n            let count = 0;\n            let lastChip = \"\";\n        \n            for (let column = 0; column < columns; column++) {\n                const chip = chipsPositions[`${row}:${column}`];\n        \n                if (chip && chip === lastChip) {\n                    count++;\n                } else {\n                    count = 1; // Reset count for new chip or empty space\n                    lastChip = chip;\n                }\n        \n                // If count reaches 4, we have a win\n                if (count === 4) {\n                    return `Player ${lastChip} won!`;\n                }\n            }\n        }\n\n        //Vertical check:\n        for (let column = 0; column < columns; column++) {\n            let count = 0;\n            let lastChip = \"\";\n        \n            for (let row = 0; row < rows; row++) {\n                const chip = chipsPositions[`${row}:${column}`];\n        \n                if (chip && chip === lastChip) {\n                    count++;\n                } else {\n                    count = 1; // Reset count for new chip or empty space\n                    lastChip = chip;\n                }\n        \n                // If count reaches 4, we have a win\n                if (count === 4) {\n                    return `Player ${lastChip} won!`;\n                }\n            }\n        }\n\n        //Check four in a row vertically\n        /*for (let column = 0; column < columns; column++) {\n            let repetitionCountStatus = { playerChip: \"\", count: 0 };\n\n            for (let row = 0;  row < rows; row++) {\n                const chip = chipsPositions[`${row}:${column}`];\n                //If there is a chip in that position, and belongs to a player, count that chip for that player\n                //either increase the count or start over\n                if (chip && chip === repetitionCountStatus.playerChip) {\n                    repetitionCountStatus.count++;\n                } else {\n                    repetitionCountStatus = { playerChip: chip, count: 1 };\n                }\n\n                //If the count for a player is 4, that player won\n                if (repetitionCountStatus.count === 4) {\n                    return `Player ${repetitionCountStatus.playerChip} won!`;\n                }\n            }\n        }*/\n\n        // Check four in a row diagonally (top-left to bottom-right)\n        for (let row = 0; row < rows; row++) {\n            for (let column = 0; column < columns; column++) { //iterates over each cell looking at rows and columns\n                const chip = chipsPositions[`${row}:${column}`];\n                if (chip) {\n                    // Check top-left to bottom-right\n                    if (\n                        row + 3 < rows &&\n                        column + 3 < columns && //Ensures we don’t go out of bounds when moving diagonally downwards and to the right.\n                        chip === chipsPositions[`${row + 1}:${column + 1}`] &&\n                        chip === chipsPositions[`${row + 2}:${column + 2}`] &&\n                        chip === chipsPositions[`${row + 3}:${column + 3}`]\n                    ) {\n                        return `Player ${chip} won!`;\n                    }\n\n                    // Check bottom-left to top-right\n                    if (\n                        row - 3 >= 0 &&\n                        column + 3 < columns &&\n                        chip === chipsPositions[`${row - 1}:${column + 1}`] &&\n                        chip === chipsPositions[`${row - 2}:${column + 2}`] &&\n                        chip === chipsPositions[`${row - 3}:${column + 3}`]\n                    ) {\n                        return `Player ${chip} won!`;\n                    }\n                }\n            }\n        }\n\n        //check if the board is full, which is another way for the game to end\n        const isBoardFull = Object.keys(chipsPositions).length === rows * columns; //The length of this array (Object.keys(chipsPositions).length) tells us exactly how many tiles are filled. If this length matches the total number of cells (rows * columns), the board is full.\n        //Object.keys = returns an array of an object's own property names (keys), in this case the object is chipPositions. The keys of chipsPositions are \"0:0\", \"0:1\", \"1:0\", \"2:2\", etc, each property name is formatted as a row and column identifier.  Object.keys provides the count of occupied positions.\n        //chipPositions keeps track of the positions of chips on the game board.\n        if (isBoardFull) {\n            return \"It's a draw!\";\n        }\n\n        //If there is no win and the board is not full, it's the next player's turn\n        return `It's ${playerTurn}'s turn`;\n    };\n\n    handleTileClick = (tileId: string) => { //This function updates the game state by placing a chip in the tile that is clicked\n        if (this.state.gameOver) { //check whether the game is over\n            return; //exit the function if the game is over\n        }\n        const { chipsPositions, playerTurn } = this.state;\n\n        //Get the last empty tile of the column\n        const column = parseInt(tileId.split(\":\")[1]); //split the tileId string at the colon (:), so we can see the row and column (as tile id is x:y, x for row and y for column), and accessing the second element [1], to get the column part. \n        //And convert it to a number with parseInt(). So column const now contains the number value of the clicked column\n        let lastEmptyTileId = this.getLastEmptyTile(column); //refers to the getLastEmptyTile() function that is specified below that identifies the lowest empty/available tile in a specified column\n\n        //If there is no empty tile in the column, do nothing\n        if (!lastEmptyTileId) { //Checks if lastEmptyTileId is falsy, meaning that there is no empty tile in the colum\n            return; //if true, exits the function\n        }\n\n        //Add chip to empty tile\n        const newChipsPositions = {\n            ...chipsPositions, //The ...chipsPositions syntax is the spread operator in JavaScript. Means that all properties from the chipsPositions object are being copied into a new object, newChipsPositions. Modifications in newChipsPositions won't affect chipsPositions\n            [lastEmptyTileId]: playerTurn //adding a new property to newChipsPositions with the key [lastEmptyTileId] and the value playerTurn, effectively placing the current player's chip in the lowest available column\n        };\n\n        //Change player turn\n        const newPlayerTurn = playerTurn == \"red\" ? \"yellow\" : \"red\"; //determines who the next player is by checking the current playerTurn, if it's red, set to yellow, otherwise it's red\n\n        //Calculate game status\n        const gameStatus = this.calculateGameStatus(newPlayerTurn, newChipsPositions); //calls calculateGameStatus() function to determine whether there is a win\n\n        //Determine if the game is over by checking whether the gameStatus string contains the word \"won\".\n        const gameOver = gameStatus.includes(\"won\");\n\n        //Save new state\n        this.setState({ chipsPositions: newChipsPositions, playerTurn: newPlayerTurn, gameStatus, gameOver }); //the React built-in setState() method updates the component's state with new values. This method is inherited from React.PureComponent\n        //setState() tells React that the component’s state has changed and that it needs to update. React then schedules a re-render of the component with the updated state values. Then it merges the new state with the current state. this.state will contain the updated state values.\n    };\n\n    getLastEmptyTile(column: number) { //identifies the lowest empty/available tile in a specified column\n        const { rows } = this.props;\n        const { chipsPositions } = this.state;\n        \n        for(let row = rows - 1; row >= 0; row--) { //this loops is going downward, starting at the total number of rows minus 1, until it reaches zero\n            const tileId = `${row}:${column}`; //\n\n            if (!chipsPositions[tileId]) { //Each key in chipsPositions is a tile ID (formatted as \"row:column\"), and the value represents the player’s chip at that position (for example, \"red\" or \"yellow\").\n                //chipsPositions[tileId] checks if there is a chip in the specified tile. tileId is the current tile's ID. ! negates this check.\n                //So !chipPositions[tileId] will be true if the tile is empty and in that case it returns the tileId\n                return tileId;\n                //This effectively ends the function early, providing the ID of the first empty tile it encounters.\n            }\n        }\n    }\n   \n    renderBoard() {\n        const { columns, rows } = this.props;\n        const { chipsPositions } = this.state;\n        return (\n            <Board\n            columns={columns}\n            rows={rows}\n            chipPositions={chipsPositions}\n            onTileClick={this.handleTileClick}\n            />\n        );\n    }\n\n    renderStatusMessage() {\n        const { gameStatus, gameOver } = this.state;\n        return <div className={styles.statusMessage}>{gameStatus} {gameOver && <p>Game over</p>}</div>;\n        //The statusMessage styles are applied to the div element, ensuring the styles are isolated and applied only within this component.\n    }\n\n    render() {\n        return (\n            <div className={styles.app}>\n                {this.renderBoard()}\n                {this.renderStatusMessage()}\n            </div>\n        );\n    }\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}